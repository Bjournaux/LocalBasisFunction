from collections import namedtuple
from pprint import pformat

import numpy as np
from numpy.lib.scimath import sqrt

from mlbspline.eval import evalMultivarSpline

# TODO: Change to 18.01528? has a 10 oom effect on ML - Python calcs for muw
nw = 1000/18.0152       # moles/kg for pure water
# dimension indices
iP = 0; iT = 1; iX = 2
# default derivative
defDer = 0
# default / full thermodynamic properties than can be generated by this function
defTdqSpec2 = frozenset(['G', 'rho', 'vel', 'Cp', 'alpha', 'U', 'H', 'S', 'Kt', 'Kp', 'Ks'])
defTdqSpec3 = frozenset(['f', 'mus', 'muw', 'Vm', 'Cpm'])


def evalSolutionGibbs(gibbsSp, x, M=0, *tdqSpec):
    # TODO: add Va, Cpa
    # TODO: check and document units for all measures
    # TODO: make it easier to add a new measure
    # TODO: make fn flexible enough to handle gibbsSp in different units (low priority)
    """ Calculates thermodynamic quantities for solutions based on a spline giving Gibbs energy
    This only supports single-solute solutions.

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Warning: units must be as specified here because some conversions are hardcoded into this function.
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    For developers: to add a new thermodynamic quantity, all of the following should be done:
    NOTE: new quantities cannot be named P, T, or X, as those symbols are reserved for the input (x)
    - determine whether it can be calculated with a PT spline or just a PTX spline
        if it can be calculated from just a PT spline, add the measure to defTdq2;
        otherwise, add to defTdqSpec3
    - determine whether it DIRECTLY requires M to be calculated (should always require a PTX spline)
        if M is required, add the condition to function checkNecessaryDataForTDQ
    - determine the derivatives of Gibbs energy DIRECTLY required to calculate the measure
        add the required conditions to function getDerivatives
    - determine the other thermodynamic quantities DIRECTLY required to calculate the measure
        add the other calculated quantities to function getFullTdqSpec
        if a new measure relies on another measure also listed in this function,
        the new measure must PRECEDE the existing measure in the list,
        so that the chain of dependencies is properly represented in the final output
    - determine whether a gridded version of the input values (x) is DIRECTLY needed to calculate the measure
        if so, add the measure to the measures in isInTdq in the getxm function
    - create a short function to calculate the measure based on other values such as gibbsSp, x, xm, derivs, tdqout, etc.
        the procedure should be named with 'eval' + the FULL name for the measure - NOT the symbol / tdq flag
        record the symbol / tdq flag as the return value in comments for the function
        add only parameters required to calculate the measure
        see evalWaterChemicalPotential function (or any other existing function) for one example
    - add the measure to the section of this function that sets values in the output value (tdqout)
        make sure the code follows the code that calculates other measures on which it depends
        and precedes  code calculating measures that depend on it (if adding multiple measures at once)
    - update the comments for param tdq with the name of the measure and its units
        be sure to add it to the correct section (PT vs PTX spline, other parameters required, etc)
        create a new section if one is warranted

    :param gibbsSp: A B-spline  (in format given by loadSpline.loadMatSpline) for giving Gibbs energy (J/mg)
                    with dimensions pressure (MPa), temperature (K), and (optionally) molality, IN THAT ORDER.
                    If molality is not provided, this function assumes that it is calculating
                    thermodynamic properties for pure water.
    :param x:       a Numpy ndarray of ndarrays with the points at which gibbsSp should be evaluated
                    the number and index of dimensions must be same as in the spline (x.size == gibbsSp['number'].size)
                    and each dimension must be sorted (low to high)
    :param M:       float with molecular weight of solute (kg/mol)
    :param tdqSpec: A list of strings indicating the thermodynamic quantities to be calculated
                    If not provided, this funtion will default to calculating the quantities in defTdq2 for a PT spline,
                    and to the union of quantities in defTdq2 and defTdqSpec3 for a PTX spline.
                    Args can be any of the following strings, each representing a thermodynamic quantity
                    that can be calculated based on a Gibbs energy spline.
                    Any other args provided will result in an error.
                        G           returns Gibbs energy in J/mg
                        rho         returns density in kg/m^3
                        vel         returns sound speed in m/s
                        Cp          returns isobaric specific heat in J/kg/K
                        alpha       returns thermal expansivity in 1/K
                        U           returns internal energy
                        H           returns enthalpy
                        S           returns entropy
                        Kt          returns isothermal bulk modulus
                        Kp          returns bulk modulus pressure derivative
                        Ks          returns isotropic bulk modulus
                        -------------------------------------------- below this line, require PTX spline and non-zero M
                        mus         returns solute chemical potential
                        muw         returns water chemical potential
                        Vm          ??
                        Cpm         ??
    :return:        a named tuple with the requested thermodynamic values
                    as named properties matching the measures requested in the *tdq parameter of this function
                    the x value is also included as tuple for reference
                    note that 0 values for concentration (x[iX]) will be replaced by eps
                    see function adjustConcentrations for details
    """
    dimCt = gibbsSp['number'].size
    tdqSpec = getFullTdqSpec(tdqSpec, dimCt)

    # TODO: issue warning if dim values fall (too far?) outside the knot sequence of gibbsSp?
    checkNecessaryDataForTDQ(M, dimCt, tdqSpec)

    # prep for calculating apparent values
    if dimCt == 3:
        # TODO: Do we really need to remove the 0ish concentrations if any were added?
        origXCt = len(x[iX])
        x[iX] = adjustConcentrations(x[iX])

    tdqout = createThermodynamicQuantitiesObj(dimCt, tdqSpec, x)

    derivs = getDerivatives(gibbsSp, x, dimCt, tdqSpec)
    xm = getxm(tdqSpec, x)

    # generate thermodynamic quantities
    if 'f' in tdqSpec:
        # TODO: document what f is
        tdqout.f = 1 + M * x[iX]
    if 'G' in tdqSpec:
        tdqout.G = evalGibbs(gibbsSp, x)
    if 'Cp' in tdqSpec:
        tdqout.Cp = evalSpecificHeat(xm, derivs)
    if 'S' in tdqSpec:
        tdqout.S = evalEntropy(derivs)
    if 'vel' in tdqSpec:
        tdqout.vel = evalSoundSpeed(derivs)
    if 'rho' in tdqSpec:
        tdqout.rho = evalDensity(derivs)
    if 'Kt' in tdqSpec:
        tdqout.Kt = evalIsothermalBulkModulus(derivs)
    if 'Kp' in tdqSpec:
        tdqout.Kp = evalBulkModulusWrtPressure(derivs)
    if 'Vm' in tdqSpec:
        # TODO: document what Vm is and add a fn for evaluating it
        tdqout.Vm = (M * derivs.d1P) + (tdqout.f * derivs.dPX)
    # these need to be done secondarily because they rely on previously generated quantities
    if 'Ks' in tdqSpec:
        tdqout.Ks = evalIsotropicBulkModulus(tdqout)
    if 'alpha' in tdqSpec:
        tdqout.alpha = evalThermalExpansivity(derivs, tdqout)
    if 'U' in tdqSpec:
        tdqout.U = evalInternalEnergy(xm, tdqout)
    if 'mus' in tdqSpec:
        tdqout.mus = evalSoluteChemicalPotential(M, derivs, tdqout)
    if 'muw' in tdqSpec:
        tdqout.muw = evalWaterChemicalPotential(xm, derivs, tdqout)
    if 'Cpm' in tdqSpec:
        # TODO: document what Cpm is and add a fn for evaluating it
        tdqout.Cpm = M * tdqout.Cp - tdqout.f * derivs.d2T1X * xm[iT]
    # these depend on secondary quantities
    if 'H' in tdqSpec:
        tdqout.H = evalEnthalpy(xm, tdqout)

    return tdqout


def checkNecessaryDataForTDQ(M, dimCt, tdqSpec):
    """ Checks error conditions before performing any calculations, throwing an error if anything doesn't match up
      - Ensures only supported measures are requested
      - Ensures necessary data is available for requested measures

    :param M:       molecular weight of solvent
    :param dimCt:   if spline being evaluated is a PT spline, this will be 2.  if a PTX spline, this will be 3
                    no other values are valid
    :param tdqSpec: the list of thermodynamic quantities to be calculated
    """
    # check for completely unsupported measures so no one has to evaluate twice because of a typo
    if not tdqSpec.issubset(defTdqSpec2 | defTdqSpec3):
        raise ValueError('One or more unsupported measures have been requested: ' +
                         pformat(tdqSpec.difference(defTdqSpec2 | defTdqSpec3)))

    # make sure that spline has 3 dims if quantities using concentration are requested
    # TODO: split this up?  may not need M for all thermodynamic quantities calculable from PTX spline
    if (dimCt == 2 or M == 0) and isInTdq(tdqSpec, defTdqSpec3):
        raise ValueError('You cannot generate any of ' + pformat(list(defTdqSpec3)) + ' with a spline that does not '
                         'include concentration, or without providing molecular weight (M).  Either remove the arg, or '
                         'provide the necessary value(s).')
    return


def getFullTdqSpec(tdqSpec, dimCt):
    if len(tdqSpec) == 0:
        tdqSpec = set(defTdqSpec2)      # make mutable
        if dimCt == 3:
            tdqSpec |= set(defTdqSpec3)
    else:

        # add thermodynamic quantities on which requested ones depend (NOT including derivatives - these handled separately)
        # first look at the ternary quantities
        if 'H' in tdqSpec:      tdqSpec |= set(['U', 'S'])
        # then look at secondary ones
        if 'Ks' in tdqSpec:     tdqSpec |= set(['rho', 'vel'])
        if 'alpha' in tdqSpec:  tdqSpec |= set(['rho'])
        if 'U' in tdqSpec:      tdqSpec |= set(['G', 'rho', 'S'])
        if 'mus' in tdqSpec:    tdqSpec |= set(['G', 'f'])
        if 'muw' in tdqSpec:    tdqSpec |= set(['G', 'f'])
        if 'Vm' in tdqSpec:     tdqSpec |= set(['f'])
        if 'Cpm' in tdqSpec:    tdqSpec |= set(['Cp', 'f'])
        if 'Cpa' in tdqSpec:    tdqSpec |= set(['Cp', 'f'])
    return tdqSpec


def createThermodynamicQuantitiesObj(dimCt, tdq, x):
    svn = set(['P', 'T'] + ([] if dimCt == 2 else ['X']))
    # TODO: include derivs in output?  fnGval returns d1P/d2P/d3P, but no others
    out = namedtuple('ThermodynamicQuantities', tdq & svn)
    # include input in the output so you always know the conditions for the thermodynamic quantities
    for i in range(0,dimCt):
        if i == iP:
            out.P = x[i]
        if i == iT:
            out.T = x[i]
        if i == iX:
            out.X = x[i]    # this might get replaced later if a zero value had to be prepended to the list
    return out


def adjustConcentrations(X):
    # TODO: properly document why eps is added in and determine whether to return amended X or original X (just to avoid divide by 0 error in Cpa and Va calcs?)
    eps = np.finfo(type(X[0])).eps  # get the lowest positive value that can be distinguished from 0
    # prepend the list of concentrations with a zero if there isn't already one there
    out = X
    # TODO: fix this when some calculation is added that uses it (Cpa or Va, possibly other quantities)
    # out = X if X[0] == 0 else np.concatenate((np.array([0]), X))
    out[out == 0] = eps  # add eps to zero concentrations to avoid divide by zero errors
    return out


def createGibbsDerivativesObj():
    # TODO: kwargs mimic main fn
    return namedtuple('GibbsDerivatives', ['d1P', 'd1T', 'd1X', 'dPT', 'dPX', 'd2P', 'd2T', 'd2T1X', 'd3P'])


def isInTdq(tdq, flags):
    return any([i for i in flags if i in tdq])


def getDerivatives(gibbsSp, x, dimCt, tdq):
    # TODO: better handle tdq - use some data structure to do the mapping
    out = createGibbsDerivativesObj()
    if isInTdq(tdq, ['rho', 'vel', 'Kt', 'Kp', 'Vm']):
        out.d1P = evalMultivarSpline(gibbsSp, x, [1 if i == iP else defDer for i in range(0, dimCt)])
    if isInTdq(tdq, ['S']):
        out.d1T = evalMultivarSpline(gibbsSp, x, [1 if i == iT else defDer for i in range(0, dimCt)])
    if isInTdq(tdq, ['mus']):
        out.d1X = evalMultivarSpline(gibbsSp, x, [1 if i == iX else defDer for i in range(0, dimCt)])
    if isInTdq(tdq, ['vel', 'alpha']):
        out.dPT = evalMultivarSpline(gibbsSp, x, [1 if (i == iP or i == iT) else defDer for i in range(0, dimCt)])
    if isInTdq(tdq, ['Vm']):
        out.dPX = evalMultivarSpline(gibbsSp, x, [1 if (i == iP or i == iX) else defDer for i in range(0, dimCt)])
    if isInTdq(tdq, ['vel', 'Kt', 'Kp']):
        out.d2P = evalMultivarSpline(gibbsSp, x, [2 if i == iP else defDer for i in range(0, dimCt)])
    if isInTdq(tdq, ['Cp', 'vel']):
        out.d2T = evalMultivarSpline(gibbsSp, x, [2 if i == iT else defDer for i in range(0, dimCt)])
    if isInTdq(tdq, ['Cpm']):
        out.d2T1X = evalMultivarSpline(gibbsSp, x,
                                             [2 if i == iT else (1 if i == iX else defDer) for i in range(0, dimCt)])
    if isInTdq(tdq, ['Kp']):
        out.d3P = evalMultivarSpline(gibbsSp, x, [3 if i == iP else defDer for i in range(0, dimCt)])
    return out


def getxm(tdq, x):
    if isInTdq(tdq, ['Cp', 'Cpa', 'Cpm', 'f', 'H', 'muw', 'U', 'Va', 'Vm']):
        return np.meshgrid(*x.tolist(), indexing='ij')    # grid the dimensions of x
    else:
        return []


def evalGibbs(gibbsSp, x):
    """
    :return: G
    """
    return evalMultivarSpline(gibbsSp, x)


def evalSpecificHeat(xm, derivs):
    """
    :return:        Cp
    """
    return -1 * derivs.d2T * xm[iT]


def evalEntropy(derivs):
    """
    :return:        S
    """
    return -1 * derivs.d1T


def evalSoundSpeed(derivs):
    """
    :return:        vel
    """
    # MPa-Pa units conversion cancels
    return np.real(sqrt(np.power(derivs.d1P, 2) / (np.power(derivs.dPT, 2) / derivs.d2T - derivs.d2P)))


def evalDensity(derivs):
    """
    :return:        rho
    """
    return 1e6 * np.power(derivs.d1P, -1)   # 1e6 for MPa to Pa


def evalIsothermalBulkModulus(derivs):
    """
    :return:        Kt
    """
    return -1 * derivs.d1P / derivs.d2P


def evalBulkModulusWrtPressure(derivs):
    """
    :return:        Kp
    """
    return derivs.d1P * np.power(derivs.d2P, -2) * derivs.d3P - 1


def evalIsotropicBulkModulus(tdq):
    """
    :param tdq:     the ThermodynamicQuantities namedtuple that stores already-calculated values
    :return:        Ks
    """
    return tdq.rho * np.power(tdq.vel, 2) / 1e6


def evalThermalExpansivity(derivs, tdq):
    """
    :param tdq:     the ThermodynamicQuantities namedtuple that stores already-calculated values
    :return:        alpha
    """
    return 1e-6 * derivs.dPT * tdq.rho  #  1e6 for MPa to Pa


def evalInternalEnergy(xm, tdq):
    """
    :param tdq:     the ThermodynamicQuantities namedtuple that stores already-calculated values
    :param xm:      gridded dimensions over which spline is being evaluated
    :return:        U
    """
    return tdq.G - 1e6 * xm[iP] / tdq.rho + xm[iT] * tdq.S


def evalSoluteChemicalPotential(M, derivs, tdq):
    """
    :param M:       the molecular weight of the solvent
    :param tdq:     the ThermodynamicQuantities namedtuple that stores already-calculated values
    :return:        mus
    """
    return M * tdq.G + tdq.f * derivs.d1X


def evalWaterChemicalPotential(xm, derivs, tdq):
    """
    :param xm:      gridded dimensions over which spline is being evaluated
    :param tdq:     the ThermodynamicQuantities namedtuple that stores already-calculated values
    :return:        muw
    """
    return (tdq.G / nw) - (1 / nw * tdq.f * xm[iX] * derivs.d1X)


def evalEnthalpy(xm, tdq):
    """
    :param xm:      gridded dimensions over which spline is being evaluated
    :param tdq:     the ThermodynamicQuantities namedtuple that stores already-calculated values
    :return:        H
    """
    return tdq.U - xm[iT] * tdq.S









